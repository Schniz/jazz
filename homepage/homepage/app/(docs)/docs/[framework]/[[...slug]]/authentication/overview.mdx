export const metadata = { title: "Authentication methods" };

import { CodeGroup, ContentByFramework } from "@/components/forMdx";

# Authentication in Jazz

Jazz authentication is based on cryptographic keys ("Account keys"). Their public part represents a user's identity, their secret part lets you act as that user.

## Authentication Flow

When a user first opens your app, they'll be in one of these states:

- **Guest Mode**: No account, read-only access to public content. Users can browse but can't save data or sync.

- **Anonymous Authentication**: Default starting point where Jazz automatically creates a local account on first visit. Data persists on one device and can be upgraded to a full account.

- **Authenticated Account**: Full account accessible across multiple devices using [passkeys](./overview#authentication-with-passkeys), [passphrases](./overview#passphrase-based-authentication), or third-party authentications, such as [Clerk](./overview#integration-with-clerk).

Anonymous Authentication can be [upgraded to an Authenticated Account](./overview#migrating-data-from-anonymous-to-authenticated-account), preserving user data.

Without authentication, users are limited to using the application on only one device.

When a user logs out of an Authenticated Account, they return to the Anonymous Authentication state with a new local account.

Here's what happens during registration and login:

- **Register**: When a user registers with an authentication provider, their Anonymous account credentials are stored in the auth provider, and the account is marked as Authenticated. The user keeps all their existing data.

- **Login**: When a user logs in with an authentication provider, their Anonymous account is discarded and the credentials are loaded from the auth provider. Data from the Anonymous account can be transferred using the [onAnonymousAccountDiscarded handler](./overview#migrating-data-from-anonymous-to-authenticated-account).

## Authentication States

Jazz provides three distinct authentication states: **Anonymous Authentication**, **Guest Mode**, and **Authenticated Account**.

### Anonymous Authentication

When a user loads a Jazz application for the first time, we create a new Account by generating keys and storing them locally. This is **Anonymous Authentication**:

- Users have full accounts with unique IDs
- Data persists between sessions on the same device
- Can be upgraded to a full account (passkey, passphrase, etc.)
- Data syncs across the network (if enabled)

### Guest Mode

**Guest Mode** provides a completely accountless context:

- No persistent identity or account
- Only provides access to publicly readable content
- Cannot save or sync user-specific data
- Suitable for read-only access to public resources

### Authenticated Account

**Authenticated Account** provides full multi-device functionality:

- Persistent identity across multiple devices
- Full access to all application features
- Data can sync across all user devices
- Multiple authentication methods available

To make Accounts work across devices, you can store/retrieve the account keys from an authentication method by using the corresponding hooks and providers.

## Detecting Authentication State
You can detect the current authentication state using `useAccountOrGuest` and `useIsAuthenticated`.

<ContentByFramework framework="react">
<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { useAccountOrGuest, useIsAuthenticated } from "jazz-react";

function AuthStateIndicator() {
  const { me } = useAccountOrGuest();
  const isAuthenticated = useIsAuthenticated();

  // Check if guest mode is enabled in JazzProvider
  const isGuest = me._type !== "Account"

  // Anonymous authentication: has an account but not fully authenticated
  const isAnonymous = !isGuest && !isAuthenticated;
  return (
    <div>
      {isGuest && <span>Guest Mode</span>}
      {isAnonymous && <span>Anonymous Account</span>}
      {isAuthenticated && <span>Authenticated</span>}
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={["react", "vue", "svelte", "vanilla"]}>
## Authentication with passkeys [!framework=react,vue,svelte,vanilla]

Passkey authentication is fully local-first and the most secure of the auth methods that Jazz provides (because keys are managed by the device/operating system itself).

It is based on the [Web Authentication API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) and is both very easy to use (using familiar FaceID/TouchID flows) and widely supported.

<ContentByFramework framework="react">
Using passkeys in Jazz is as easy as this:
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { useState } from "react";
import { usePasskeyAuth } from "jazz-react";
type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [username, setUsername] = useState("");

  const auth = usePasskeyAuth({ // Must be inside the JazzProvider!
    appName: "My super-cool web app",
  });

  if (auth.state === "signedIn") { // You can also use `useIsAuthenticated()`
    return <div>You are already signed in</div>;
  }

  const handleSignUp = async () => {
    await auth.signUp(username);
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn();
    onOpenChange(false);
  };

  return (
    <div>
      <button onClick={handleLogIn}>Log in</button>
      <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />
      <button onClick={handleSignUp}>Sign up</button>
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>

You can try our passkey authentication using our [passkey example](https://passkey-demo.jazz.tools/) or the [music player demo](https://music-demo.jazz.tools/).

</ContentByFramework>

## Passphrase-based authentication

Passphrase authentication lets users log into any device using a Bitcoin-style passphrase. This means users are themselves responsible for storing the passphrase safely.

The passphrase is generated from the local account certificate using a wordlist of your choice.

You can find a set of ready-to-use wordlists in the [bip39](https://github.com/bitcoinjs/bip39/tree/a7ecbfe2e60d0214ce17163d610cad9f7b23140c/src/wordlists) repository.

<ContentByFramework framework="react">
For example:
<CodeGroup>
```tsx twoslash
// @filename: wordlist.ts
export const wordlist = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "honeydew", "kiwi", "lemon", "mango", "orange", "pear", "quince", "raspberry", "strawberry", "tangerine", "uva", "watermelon", "xigua", "yuzu", "zucchini"];
// @filename: AuthModal.tsx
import * as React from "react";
import { useState } from "react";
import { usePassphraseAuth } from "jazz-react";
type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
import { wordlist } from "./wordlist"

export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [loginPassphrase, setLoginPassphrase] = useState("");

  const auth = usePassphraseAuth({ // Must be inside the JazzProvider!
    wordlist: wordlist,
  });

  if (auth.state === "signedIn") { // You can also use `useIsAuthenticated()`
    return <div>You are already signed in</div>;
  }

  const handleSignUp = async () => {
    await auth.signUp();
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn(loginPassphrase);
    onOpenChange(false);
  };

  return (
    <div>
      <label>
        Your current passphrase
        <textarea
          readOnly
          value={auth.passphrase}
          rows={5}
        />
      </label>
      <button onClick={handleSignUp}>I have stored my passphrase</button>
      <label>
        Log in with your passphrase
        <textarea
          value={loginPassphrase}
          onChange={(e) => setLoginPassphrase(e.target.value)}
          placeholder="Enter your passphrase"
          rows={5}
          required
        />
      </label>
      <button onClick={handleLogIn}>Log in</button>
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={["react-native", "react-native-expo"]}>
For example:
<CodeGroup>
```tsx twoslash
// @filename: wordlist.ts
export const wordlist = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "honeydew", "kiwi", "lemon", "mango", "orange", "pear", "quince", "raspberry", "strawberry", "tangerine", "uva", "watermelon", "xigua", "yuzu", "zucchini"];
// @filename: AuthModal.tsx
import * as React from "react";
import { View, TextInput, Button, Text } from 'react-native';
import { useState } from "react";
import { usePassphraseAuth } from "jazz-react-native";

type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
import { wordlist } from "./wordlist"

export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [loginPassphrase, setLoginPassphrase] = useState("");

  const auth = usePassphraseAuth({
    wordlist: wordlist,
  });

  if (auth.state === "signedIn") {
    return <Text>You are already signed in</Text>;
  }

  const handleSignUp = async () => {
    await auth.signUp();
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn(loginPassphrase);
    onOpenChange(false);
  };

  return (
    <View>
      <View>
        <Text>Your current passphrase</Text>
        <TextInput
          editable={false}
          value={auth.passphrase}
          multiline
          numberOfLines={5}
        />
      </View>

      <Button
        title="I have stored my passphrase"
        onPress={handleSignUp}
      />

      <View>
        <Text>Log in with your passphrase</Text>
        <TextInput
          value={loginPassphrase}
          onChangeText={setLoginPassphrase}
          placeholder="Enter your passphrase"
          multiline
          numberOfLines={5}
        />
      </View>

      <Button
        title="Log in"
        onPress={handleLogIn}
      />
    </View>
  );
}
```
</CodeGroup>
</ContentByFramework>

You can see passphrase authentication in our [passphrase example](https://passphrase-demo.jazz.tools/) or the [todo list demo](https://todo-demo.jazz.tools/).

## Integration with Clerk
<ContentByFramework framework="react-native">
We do not currently support Clerk in React Native, but we do in [React Native Expo](/docs/react-native-expo/authentication/overview#integration-with-clerk).
</ContentByFramework>

<ContentByFramework framework={["react", "react-native-expo", "svelte", "vue", "vanilla"]}>

Jazz can be used with [Clerk](https://clerk.com/) to authenticate users.

This authentication method is not fully local-first, because the login and signup need to be done while online. Clerk and anyone who is an admin in the app's Clerk org are trusted with the user's key secret and could impersonate them.

However, once authenticated, your users won't need to interact with Clerk anymore, and are able to use all of Jazz's features without needing to be online.
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
You can use the `JazzProviderWithClerk` component to wrap your app.  Note the `__experimental_resourceCache` option.  This helps render Clerk components when offline.
</ContentByFramework>

<ContentByFramework framework="react">
We offer Clerk integration through our package: [`jazz-react-auth-clerk`](https://npmjs.com/package/jazz-react-auth-clerk).

After installing, you can use `<JazzProviderWithClerk />` to wrap your app.

<CodeGroup>
```tsx twoslash
import * as React from "react";
import { createRoot } from "react-dom/client";
const apiKey = "you@example.com";
const PUBLISHABLE_KEY = "fake_key";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
import { useClerk, ClerkProvider } from '@clerk/clerk-react';
import { JazzProviderWithClerk } from "jazz-react-auth-clerk";

function JazzProvider({ children }: { children: React.ReactNode }) {
  const clerk = useClerk();

  return (
    <JazzProviderWithClerk
      clerk={clerk}
      sync={{
        peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
      }}
    >
      {children}
    </JazzProviderWithClerk>
  );
}

createRoot(document.getElementById("root")!).render(
  <ClerkProvider publishableKey={PUBLISHABLE_KEY} afterSignOutUrl="/">
    <JazzProvider>
      <App />
    </JazzProvider>
  </ClerkProvider>
);
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { Slot } from "expo-router";
const apiKey = "you@example.com";
const tokenCache = {
  getToken: async (key: string) => {
    return null;
  },
  saveToken: async (key: string, token: string) => {},
  clearToken: async (key: string) => {},
};
// ---cut---
import { useClerk, ClerkProvider, ClerkLoaded } from '@clerk/clerk-expo';
import { secureStore } from "@clerk/clerk-expo/secure-store";
import { JazzProviderWithClerk } from "jazz-expo/auth/clerk";

function JazzAndAuth({ children }: { children: React.ReactNode }) {
  const clerk = useClerk();

  return (
    <JazzProviderWithClerk
      clerk={clerk}
      sync={{
        peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
      }}
    >
      {children}
    </JazzProviderWithClerk>
  );
}

export default function RootLayout() {
  const publishableKey = process.env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY;

  if (!publishableKey) {
    throw new Error(
      "Missing Publishable Key. Please set EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY in your .env",
    );
  }

  return (
    <ClerkProvider
      tokenCache={tokenCache}
      publishableKey={publishableKey}
      __experimental_resourceCache={secureStore}
    >
      <ClerkLoaded>
        <JazzAndAuth>
          <Slot />
        </JazzAndAuth>
      </ClerkLoaded>
    </ClerkProvider>
  );
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react">
Then you can use the [Clerk auth methods](https://clerk.com/docs/references/react/overview) to log in and sign up:
<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { SignInButton } from "@clerk/clerk-react";
import { useAccount, useIsAuthenticated } from "jazz-react";

export function AuthButton() {
  const { logOut } = useAccount();

  const isAuthenticated = useIsAuthenticated();

  if (isAuthenticated) {
    return <button onClick={() => logOut()}>Logout</button>;
  }

  return <SignInButton />;
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
Then you can use the [Clerk auth methods](https://clerk.com/docs/references/expo/overview) to log in and sign up:
<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { useSignIn } from "@clerk/clerk-expo";
import { useAccount, useIsAuthenticated } from "jazz-expo";
import { Button, Text } from 'react-native';

export function AuthButton() {
  const { logOut } = useAccount();
  const { signIn, setActive, isLoaded } = useSignIn();
  const isAuthenticated = useIsAuthenticated();

  if (isAuthenticated) {
    return <Button title="Logout" onPress={() => logOut()} />;
  }

  const onSignInPress = async () => {
    if (!isLoaded) return;
    const signInAttempt = await signIn.create({
      identifier: "you@example.com",
      password: "password",
    });
    if (signInAttempt.status === "complete") {
      await setActive({ session: signInAttempt.createdSessionId });
    }
  };

  return <Button title="Sign In" onPress={onSignInPress} />;
}
```
</CodeGroup>
</ContentByFramework>

## Migrating data from anonymous to authenticated account

You may want to allow your users to use your app with Anonymous Authentication (for poll responses, quick trials, etc.). When *signing up*, their anonymous account is transparently upgraded using the provided auth method, keeping the data stored in the account intact.

However, a user may realise that they already have an existing account *after using the app anonymously and having already stored data in the anonymous account*.

When they now *log in*, by default the anonymous account will be discarded and this could lead to unexpected data loss.

To avoid this situation we provide the `onAnonymousAccountDiscarded` handler to migrate the data from the anonymous account to the existing authenticated one.

This is an example from our [music player example app](https://github.com/garden-co/jazz/tree/main/examples/music-player):
<CodeGroup>
```ts twoslash
import { Account, Group, CoMap, co, CoList } from "jazz-tools";

class MusicTrack extends CoMap {
  title = co.string;
  duration = co.number;
  isExampleTrack = co.optional.boolean;
}
class ListOfTracks extends CoList.Of(co.ref(MusicTrack)) {}
class Playlist extends CoMap {
  title = co.string;
  tracks = co.ref(ListOfTracks);
}
class MusicaAccountRoot extends CoMap {
  rootPlaylist = co.ref(Playlist);
}
class MusicaAccount extends Account {
  root = co.ref(MusicaAccountRoot);
}

// ---cut---
export async function onAnonymousAccountDiscarded(
  anonymousAccount: MusicaAccount,
) {
  const { root: anonymousAccountRoot } = await anonymousAccount.ensureLoaded({
    resolve: {
      root: {
        rootPlaylist: {
          tracks: {
            $each: true,
          },
        },
      },
    },
  });

  const me = await MusicaAccount.getMe().ensureLoaded({
    resolve: {
      root: {
        rootPlaylist: {
          tracks: true,
        },
      },
    },
  });

  for (const track of anonymousAccountRoot.rootPlaylist.tracks) {
    if (track.isExampleTrack) continue;

    const trackGroup = track._owner.castAs(Group);
    trackGroup.addMember(me, "admin");

    me.root.rootPlaylist.tracks.push(track);
  }
}
```
</CodeGroup>

To see how this works in reality we suggest you to try
to upload a song in the [music player demo](https://music-demo.jazz.tools/) and then
try to log in with an existing account.

## Controlling sync for different authentication states

You can control network sync with [Providers](/docs/project-setup/providers) based on authentication state:

- `when: "always"`: Sync is enabled for both Anonymous Authentication and Authenticated Account
- `when: "signedUp"`: Sync is enabled when the user is authenticated
- `when: "never"`: Sync is disabled, content stays local

<ContentByFramework framework="react">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { JazzProvider } from "jazz-react";
const apiKey = "you@example.com";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
<JazzProvider
  sync={{
    peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
     // Controls when sync is enabled for
     // both Anonymous Authentication and Authenticated Account
    when: "always", // or "signedUp" or "never"
  }}
>
  <App />
</JazzProvider>
```
</CodeGroup>
</ContentByFramework>

### Disable sync for Anonymous Authentication

You can disable network sync to make your app local-only under specific circumstances.

For example, you may want to give users with Anonymous Authentication the opportunity to try your app locally-only (incurring no sync traffic), then enable network sync only when the user is fully authenticated.

<ContentByFramework framework="react">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { JazzProvider } from "jazz-react";
const apiKey = "you@example.com";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
<JazzProvider
  sync={{
    peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
     // This makes the app work in local mode when using Anonymous Authentication
    when: "signedUp",
  }}
>
  <App />
</JazzProvider>
```
</CodeGroup>
</ContentByFramework>
### Configuring Guest Mode Access

You can configure Guest Mode access with the `guestMode` prop for [Providers](/docs/project-setup/providers).

<ContentByFramework framework="react">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { JazzProvider } from "jazz-react";
const apiKey = "you@example.com";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
<JazzProvider
  // Enable Guest Mode for public content
  guestMode={true}
  sync={{
    peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
    // Only sync for authenticated users
    when: "signedUp",
  }}
>
  <App />
</JazzProvider>
```
</CodeGroup>
</ContentByFramework>

For more complex behaviours, you can manually control sync by statefully switching when between `"always"` and `"never"`.