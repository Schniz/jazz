export const metadata = { title: "Authentication methods" };

import { CodeGroup, ContentByFramework } from "@/components/forMdx";

# Authentication in Jazz

Jazz authentication is based on cryptographic keys ("Account keys"). Their public part represents a user's identity, their secret part lets you act as that user.

## Authentication States

Jazz has two distinct states for users without traditional sign-in: **Anonymous Authentication** and **Guest Mode**.

### Anonymous Authentication

When a user loads a Jazz application for the first time, we create a new Account by generating keys and storing them locally. This is **Anonymous Authentication**:

- Users have full accounts with unique IDs
- Data persists between sessions on the same device
- Can be upgraded to a full account (passkey, passphrase, etc.)
- Data syncs across the network (if enabled)

### Guest Mode

**Guest Mode** provides a completely accountless context:

- No persistent identity or account
- Only provides access to publicly readable content
- Cannot save or sync user-specific data
- Suitable for read-only access to public resources

Without additional authentication steps beyond Anonymous Authentication, users can use Jazz normally but would be limited to using the application on only one device.

To make Accounts work across devices, you can store/retrieve the account keys from an authentication method by using the corresponding hooks and providers.

## Detecting Authentication State

<ContentByFramework framework="react">
You can detect the current authentication state using the following hooks:

<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { useAccount, useIsAuthenticated } from "jazz-react";

function AuthStateIndicator() {
  const { me } = useAccount();
  const isAuthenticated = useIsAuthenticated();

  // Check if guest mode is enabled in JazzProvider
  const isGuest = !me && !isAuthenticated;

  // Anonymous authentication: has an account but not fully authenticated
  const isAnonymous = !!me && !isAuthenticated;
  return (
    <div>
      {isGuest && <span>Guest Mode</span>}
      {isAnonymous && <span>Anonymous Account</span>}
      {isAuthenticated && <span>Authenticated</span>}
    </div>
  );
}
```
</CodeGroup>
For more examples, see the [Authentication States Guide](./auth-states-guide.mdx).
</ContentByFramework>

<ContentByFramework framework={["react", "vue", "svelte"]}>
## Authentication with passkeys [!framework=react,vue,svelte]

Passkey authentication is fully local-first and the most secure of the auth methods that Jazz provides (because keys are managed by the device/operating system itself).

It is based on the [Web Authentication API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API) and is both very easy to use (using familiar FaceID/TouchID flows) and widely supported.

<ContentByFramework framework="react">
Using passkeys in Jazz is as easy as this:
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { useState } from "react";
import { usePasskeyAuth } from "jazz-react";
type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [username, setUsername] = useState("");

  const auth = usePasskeyAuth({ // Must be inside the JazzProvider!
    appName: "My super-cool web app",
  });

  if (auth.state === "signedIn") { // You can also use `useIsAuthenticated()`
    return <div>You are already signed in</div>;
  }

  const handleSignUp = async () => {
    await auth.signUp(username);
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn();
    onOpenChange(false);
  };

  return (
    <div>
      <button onClick={handleLogIn}>Log in</button>
      <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />
      <button onClick={handleSignUp}>Sign up</button>
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>


You can try our passkey authentication using our [passkey example](https://passkey-demo.jazz.tools/) or the [music player demo](https://music-demo.jazz.tools/).

</ContentByFramework>

## Passphrase-based authentication

Passphrase authentication lets users log into any device using a Bitcoin-style passphrase. This means users are themselves responsible for storing the passphrase safely.

The passphrase is generated from the local account certificate using a wordlist of your choice.

You can find a set of ready-to-use wordlists in the [bip39](https://github.com/bitcoinjs/bip39/tree/a7ecbfe2e60d0214ce17163d610cad9f7b23140c/src/wordlists) repository.

<ContentByFramework framework="react">
For example:
<CodeGroup>
```tsx twoslash
// @filename: wordlist.ts
export const wordlist = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "honeydew", "kiwi", "lemon", "mango", "orange", "pear", "quince", "raspberry", "strawberry", "tangerine", "uva", "watermelon", "xigua", "yuzu", "zucchini"];
// @filename: AuthModal.tsx
import * as React from "react";
import { useState } from "react";
import { usePassphraseAuth } from "jazz-react";
type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
import { wordlist } from "./wordlist"

export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [loginPassphrase, setLoginPassphrase] = useState("");

  const auth = usePassphraseAuth({ // Must be inside the JazzProvider!
    wordlist: wordlist,
  });

  if (auth.state === "signedIn") { // You can also use `useIsAuthenticated()`
    return <div>You are already signed in</div>;
  }

  const handleSignUp = async () => {
    await auth.signUp();
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn(loginPassphrase);
    onOpenChange(false);
  };

  return (
    <div>
      <label>
        Your current passphrase
        <textarea
          readOnly
          value={auth.passphrase}
          rows={5}
        />
      </label>
      <button onClick={handleSignUp}>I have stored my passphrase</button>
      <label>
        Log in with your passphrase
        <textarea
          value={loginPassphrase}
          onChange={(e) => setLoginPassphrase(e.target.value)}
          placeholder="Enter your passphrase"
          rows={5}
          required
        />
      </label>
      <button onClick={handleLogIn}>Log in</button>
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={["react-native", "react-native-expo"]}>
For example:
<CodeGroup>
```tsx twoslash
// @filename: wordlist.ts
export const wordlist = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "honeydew", "kiwi", "lemon", "mango", "orange", "pear", "quince", "raspberry", "strawberry", "tangerine", "uva", "watermelon", "xigua", "yuzu", "zucchini"];
// @filename: AuthModal.tsx
import * as React from "react";
import { View, TextInput, Button, Text } from 'react-native';
import { useState } from "react";
import { usePassphraseAuth } from "jazz-react";

type AuthModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}
// ---cut---
import { wordlist } from "./wordlist"

export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const [loginPassphrase, setLoginPassphrase] = useState("");

  const auth = usePassphraseAuth({
    wordlist: wordlist,
  });

  if (auth.state === "signedIn") {
    return <Text>You are already signed in</Text>;
  }

  const handleSignUp = async () => {
    await auth.signUp();
    onOpenChange(false);
  };

  const handleLogIn = async () => {
    await auth.logIn(loginPassphrase);
    onOpenChange(false);
  };

  return (
    <View>
      <View>
        <Text>Your current passphrase</Text>
        <TextInput
          editable={false}
          value={auth.passphrase}
          multiline
          numberOfLines={5}
        />
      </View>

      <Button
        title="I have stored my passphrase"
        onPress={handleSignUp}
      />

      <View>
        <Text>Log in with your passphrase</Text>
        <TextInput
          value={loginPassphrase}
          onChangeText={setLoginPassphrase}
          placeholder="Enter your passphrase"
          multiline
          numberOfLines={5}
        />
      </View>

      <Button
        title="Log in"
        onPress={handleLogIn}
      />
    </View>
  );
}
```
</CodeGroup>
</ContentByFramework>

You can try our passphrase authentication using our [passphrase example](https://passphrase-demo.jazz.tools/) or the [todo list demo](https://todo-demo.jazz.tools/).

<ContentByFramework framework={["react", "react-native-expo"]}>
## Integration with Clerk

Jazz can be used with [Clerk](https://clerk.com/) to authenticate users.

This authentication method is not fully local-first, because the login and signup need to be done while online. Clerk and anyone who is an admin in the app's Clerk org are trusted with the user's key secret and could impersonate them.

However, once authenticated, your users won't need to interact with Clerk anymore, and are able to use all of Jazz's features without needing to be online.
</ContentByFramework>

<ContentByFramework framework="react">
The clerk provider is not built into `jazz-react` and needs the `jazz-react-auth-clerk` package to be installed.

After installing the package you can use the `JazzProviderWithClerk` component to wrap your app:
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
You can use the `JazzProviderWithClerk` component to wrap your app.  Note the `__experimental_resourceCache` option.  This helps render Clerk components when offline.
</ContentByFramework>

<ContentByFramework framework="react">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { createRoot } from "react-dom/client";
const apiKey = "example@garden.co";
const PUBLISHABLE_KEY = "fake_key";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
import { useClerk, ClerkProvider } from '@clerk/clerk-react';
import { JazzProviderWithClerk } from "jazz-react-auth-clerk";

function JazzProvider({ children }: { children: React.ReactNode }) {
  const clerk = useClerk();

  return (
    <JazzProviderWithClerk
      clerk={clerk}
      sync={{
        peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
      }}
    >
      {children}
    </JazzProviderWithClerk>
  );
}

createRoot(document.getElementById("root")!).render(
  <ClerkProvider publishableKey={PUBLISHABLE_KEY} afterSignOutUrl="/">
    <JazzProvider>
      <App />
    </JazzProvider>
  </ClerkProvider>
);
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { Slot } from "expo-router";
const apiKey = "example@garden.co";
const tokenCache = {
  getToken: async (key: string) => {
    return null;
  },
  saveToken: async (key: string, token: string) => {},
  clearToken: async (key: string) => {},
};
// ---cut---
import { useClerk, ClerkProvider, ClerkLoaded } from '@clerk/clerk-expo';
import { secureStore } from "@clerk/clerk-expo/secure-store";
import { JazzProviderWithClerk } from "jazz-expo/auth/clerk";

function JazzAndAuth({ children }: { children: React.ReactNode }) {
  const clerk = useClerk();

  return (
    <JazzProviderWithClerk
      clerk={clerk}
      sync={{
        peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
      }}
    >
      {children}
    </JazzProviderWithClerk>
  );
}

export default function RootLayout() {
  const publishableKey = process.env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY;

  if (!publishableKey) {
    throw new Error(
      "Missing Publishable Key. Please set EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY in your .env",
    );
  }

  return (
    <ClerkProvider
      tokenCache={tokenCache}
      publishableKey={publishableKey}
      __experimental_resourceCache={secureStore}
    >
      <ClerkLoaded>
        <JazzAndAuth>
          <Slot />
        </JazzAndAuth>
      </ClerkLoaded>
    </ClerkProvider>
  );
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react">
Then you can use the [Clerk auth methods](https://clerk.com/docs/references/react/overview) to log in and sign up:
<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { SignInButton } from "@clerk/clerk-react";
import { useAccount, useIsAuthenticated } from "jazz-react";

export function AuthButton() {
  const { logOut } = useAccount();

  const isAuthenticated = useIsAuthenticated();

  if (isAuthenticated) {
    return <button onClick={() => logOut()}>Logout</button>;
  }

  return <SignInButton />;
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="react-native-expo">
Then you can use the [Clerk auth methods](https://clerk.com/docs/references/expo/overview) to log in and sign up:
<CodeGroup>
```tsx twoslash
import * as React from "react";
// ---cut---
import { useSignIn } from "@clerk/clerk-expo";
import { useAccount, useIsAuthenticated } from "jazz-expo";
import { Button, Text } from 'react-native';

export function AuthButton() {
  const { logOut } = useAccount();
  const { signIn, setActive, isLoaded } = useSignIn();
  const isAuthenticated = useIsAuthenticated();

  if (isAuthenticated) {
    return <Button title="Logout" onPress={() => logOut()} />;
  }

  const onSignInPress = async () => {
    if (!isLoaded) return;
    const signInAttempt = await signIn.create({
      identifier: "user@example.com",
      password: "password",
    });
    if (signInAttempt.status === "complete") {
      await setActive({ session: signInAttempt.createdSessionId });
    }
  };

  return <Button title="Sign In" onPress={onSignInPress} />;
}
```
</CodeGroup>
</ContentByFramework>

## Migrating data from anonymous to authenticated account

You may want to allow your users to use your app with Anonymous Authentication (for poll responses, quick trials, etc.). When *signing up*, their anonymous account is transparently upgraded using the provided auth method, keeping the data stored in the account intact.

However, a user may realise that they already have an existing account *after using the app anonymously and having already stored data in the anonymous account*.

When they now *log in*, by default the anonymous account will be discarded and this could lead to unexpected data loss.

To avoid this situation we provide the `onAnonymousAccountDiscarded` handler to migrate the data from the anonymous account to the existing authenticated one.

This is an example from our [music player example app](https://github.com/garden-co/jazz/tree/main/examples/music-player):
<CodeGroup>
```ts twoslash
import { Account, Group, CoMap, co, CoList } from "jazz-tools";

class MusicTrack extends CoMap {
  title = co.string;
  duration = co.number;
  isExampleTrack = co.optional.boolean;
}
class ListOfTracks extends CoList.Of(co.ref(MusicTrack)) {}
class Playlist extends CoMap {
  title = co.string;
  tracks = co.ref(ListOfTracks);
}
class MusicaAccountRoot extends CoMap {
  rootPlaylist = co.ref(Playlist);
}
class MusicaAccount extends Account {
  root = co.ref(MusicaAccountRoot);
}

// ---cut---
export async function onAnonymousAccountDiscarded(
  anonymousAccount: MusicaAccount,
) {
  const { root: anonymousAccountRoot } = await anonymousAccount.ensureLoaded({
    resolve: {
      root: {
        rootPlaylist: {
          tracks: {
            $each: true,
          },
        },
      },
    },
  });

  const me = await MusicaAccount.getMe().ensureLoaded({
    resolve: {
      root: {
        rootPlaylist: {
          tracks: true,
        },
      },
    },
  });

  for (const track of anonymousAccountRoot.rootPlaylist.tracks) {
    if (track.isExampleTrack) continue;

    const trackGroup = track._owner.castAs(Group);
    trackGroup.addMember(me, "admin");

    me.root.rootPlaylist.tracks.push(track);
  }
}
```
</CodeGroup>

To see how this works in reality we suggest you to try
to upload a song in the [music player demo](https://music-demo.jazz.tools/) and then
try to log in with an existing account.

## Controlling sync for different authentication states

You can control network sync based on authentication state:

### Disable sync for Anonymous Authentication

You can disable network sync to make your app local-only under specific circumstances.

For example, you may want to give users with Anonymous Authentication the opportunity to try your app locally-only (incurring no sync traffic), then enable network sync only when the user is fully authenticated:
<CodeGroup>
```tsx twoslash
import * as React from "react";
import { JazzProvider } from "jazz-react";
const apiKey = "example@garden.co";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
<JazzProvider
  sync={{
    peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
     // This makes the app work in local mode when using Anonymous Authentication
    when: "signedUp",
  }}
>
  <App />
</JazzProvider>
```
</CodeGroup>

### Configuring Guest Mode Access

To implement Guest Mode (completely accountless):

<CodeGroup>
```tsx twoslash
import * as React from "react";
import { JazzProvider } from "jazz-react";
const apiKey = "example@garden.co";
function App() {
  return <div>Hello World</div>;
}
// ---cut---
<JazzProvider
  // Enable Guest Mode for public content
  guestMode={true}
  sync={{
    peer: `wss://cloud.jazz.tools/?key=${apiKey}`,
    // Only sync for authenticated users
    when: "signedUp",
  }}
>
  <App />
</JazzProvider>
```
</CodeGroup>
For more complex behaviours, you can manually control sync by statefully switching when between `"always"` and `"never"`.
