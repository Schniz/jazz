export const metadata = { title: "Public sharing and invites" };

import { ContentByFramework, CodeGroup } from '@/components/forMdx'

# Public sharing and invites

...more docs coming soon

## Public sharing

You can share CoValues publicly by setting the `owner` to a `Group`, and granting
access to "everyone".

<CodeGroup>
  ```ts
  const group = Group.create();
  group.addMember("everyone", "writer"); // *highlight*
  ```
</CodeGroup>

This is done in the [chat example](https://github.com/garden-co/jazz/tree/main/examples/chat) where anyone can join the chat, and send messages.

You can also [add members by Account ID](/docs/groups/intro#adding-group-members-by-id).

## Invites

You can grant users access to a CoValue by sending them an invite link.

This is used in the [pet example](https://github.com/garden-co/jazz/tree/main/examples/pets)
and the [todo example](https://github.com/garden-co/jazz/tree/main/examples/todo).

<ContentByFramework  framework="react">
<CodeGroup>
```ts
import { createInviteLink } from "jazz-react";

createInviteLink(organization, "writer"); // or reader, or admin
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework  framework="react-native">
<CodeGroup>
```ts
import { createInviteLink } from "jazz-react-native";

createInviteLink(organization, "writer"); // or reader, or admin
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework  framework="react-native-expo">
<CodeGroup>
```ts
import { createInviteLink } from "jazz-expo";

createInviteLink(organization, "writer"); // or reader, or admin
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework  framework="vue">
<CodeGroup>
```ts
import { createInviteLink } from "jazz-vue";

createInviteLink(organization, "writer"); // or reader, or admin
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework  framework="svelte">
<CodeGroup>
```ts
import { createInviteLink } from "jazz-browser";

createInviteLink(organization, "writer"); // or reader, or admin
```
</CodeGroup>
</ContentByFramework>

It generates a URL that looks like `.../invite/[CoValue ID]/[inviteSecret]`

In your app, you need to handle this route, and let the user accept the invitation,
as done [here](https://github.com/garden-co/jazz/tree/main/examples/pets/src/2_main.tsx).

<CodeGroup>
```ts
useAcceptInvite({
  invitedObjectSchema: PetPost,
  onAccept: (petPostID) => navigate("/pet/" + petPostID),
});
```
</CodeGroup>


### Requesting Invites

To allow a non-group member to request an invitation to a group you can use the `writeOnly` role.
This means that users only have write access to a specific requests list (they can't read other requests). 
However, Administrators can review and approve these requests.

First, your data models

<CodeGroup>
```ts twoslash
// @errors: 2345;
import { CoMap, co, CoValue } from "jazz-tools";

class Request extends CoMap {
  // Add properties as needed for your Request class
  message = co.string;
  status = co.string;
}

export class RequestsList extends CoMap.Record(co.ref(Request)) {};

// ---cut-before---
class RequestsToJoin extends CoMap {
  writeOnlyInvite = co.string;  // Stores the write-only invite link
  requests = co.ref(RequestsList);  // Reference to all requests
}
```
</CodeGroup>

Next, set up the request system with appropriate access controls

<CodeGroup>
```ts twoslash
import { Group, co, CoList, CoMap, Account } from "jazz-tools";
import { createInviteLink } from "jazz-react";

class Project extends CoMap {
  title = co.string;
  account = co.ref(Account);
}

class Request extends CoMap {
  message = co.string;
  status = co.string;
}

export class RequestsList extends CoMap.Record(co.ref(Request)) {};

export class RequestsToJoin extends CoMap {
  writeOnlyInvite = co.string;
  requests = co.ref(RequestsList);
}

// ---cut-before---
function createRequestsToJoin() {
  const everyoneReaderGroup = Group.create();
  everyoneReaderGroup.addMember("everyone", "reader");

  const requestsGroup = Group.create();
  const writeOnlyInvite = createInviteLink(requestsGroup, "writeOnly");

  return RequestsToJoin.create({ 
    writeOnlyInvite, 
    requests: RequestsList.create({}, requestsGroup)
  }, everyoneReaderGroup);
}
```
</CodeGroup>

Using the write-only invitation link, users can submit requests.

<CodeGroup>
```ts twoslash
// @errors: 2554 2559
import { co, CoList, CoMap, ID, Account, CoValue, CoValueClass, Group } from "jazz-tools";
import { createInviteLink } from "jazz-react";

type JsonValue = string | number | boolean | null | { [key: string]: JsonValue } | JsonValue[];
type JsonObject = { [key: string]: JsonValue };
type RawCoMap<T extends Record<string, any>, M extends JsonObject | null> = {
  _raw: { data: T; metadata: M };
};

class Project extends CoMap {
  title = co.string;
  account = co.ref(Account);
}

class Request extends CoMap {
  project = co.ref(Project);
  account = co.ref(Account);
}
const mockArrayType = (type: any) => type; // Just for demonstration purposes

export class RequestsList extends CoMap {
  // Using mock helper instead of non-existent co.array
  items = mockArrayType(co.ref(Request));
}

export class RequestsToJoin extends CoMap {
  writeOnlyInvite = co.string;
  requests = co.ref(RequestsList);
}

async function loadRequestsToJoin(projectId: ID<Project>): Promise<RequestsToJoin | null> {
  // Mock implementation
  return new RequestsToJoin();
}

// Mock function for consumeInviteLink
interface ConsumeInviteLinkOptions {
  inviteURL: string;
  invitedObjectSchema?: any;
}

interface ConsumeInviteLinkResult {
  success: boolean;
  valueID: string;
  writeable: boolean;
  fromRaw: RawCoMap<{ [key: string]: JsonValue | undefined }, JsonObject | null>;
}

async function consumeInviteLink(options: ConsumeInviteLinkOptions): Promise<ConsumeInviteLinkResult | null> {
  if (!options.inviteURL) {
    return null;
  }
  return {
    success: true,
    valueID: "mock-value-id-123",
    writeable: true,
    fromRaw: {} as RawCoMap<{ [key: string]: JsonValue | undefined }, JsonObject | null>
  };
}

// ---cut-before---

function createRequestsToJoin() {
  const everyoneReaderGroup = Group.create()
  everyoneReaderGroup.addMember("everyone", "reader")

  const requestsGroup = Group.create()
  const writeOnlyInvite = createInviteLink(requestsGroup, "writeOnly")
  
  return RequestsToJoin.create({ writeOnlyInvite, requests: RequestsList.create({ items: [] }, requestsGroup) },  everyoneReaderGroup)
}

```
</CodeGroup>
Then, administrators can review and approve requests.
<CodeGroup>
```ts twoslash
// @errors: 2339 2345 18047 2769
import { co, CoMap, ID, Account, Group } from "jazz-tools";

// Reusing the same types from previous examples
class Project extends CoMap {
  title = co.string;
}

class Request extends CoMap {
  project = co.ref(Project);
  account = co.ref(Account);
  message = co.string;
  status = co.string; // Can be "pending", "approved", "rejected"
}

export class RequestsList extends CoMap {
  // Use mockArrayType helper instead of non-existent co.list
  items = mockArrayType(co.ref(Request));
}

// Helper function to mock the co.list functionality
const mockArrayType = (type: any) => type;

export class RequestsToJoin extends CoMap {
  writeOnlyInvite = co.string;
  requests = co.ref(RequestsList);
}
async function reviewJoinRequests(requestsToJoinId: ID<RequestsToJoin>) {
  const requestsToJoin = await RequestsToJoin.load(requestsToJoinId);
  
  if (!requestsToJoin || !requestsToJoin.requests) {
    throw new Error("Requests container not found");
  }
  
  const requestsList = await RequestsList.load(requestsToJoin.requests.id);
  if (!requestsList) {
    throw new Error("Requests list not found");
  }
    return requestsList.items;
}

// ---cut-before---

async function approveJoinRequest(requestsToJoinId: ID<RequestsToJoin>, requestId: ID<Request>, targetGroup: ID<Group>) {
  const requestsToJoin = await RequestsToJoin.load(requestsToJoinId);
  
  if (!requestsToJoin || !requestsToJoin.requests) {
    throw new Error("Requests container not found");
  }
  
  const requestsList = await RequestsList.load(requestsToJoin.requests.id);
  
  const request = await Request.load(requestId);
  
  if (!request) {
    throw new Error("Request not found");
  }
    request.status = "approved";
  
  const group = await Group.load(targetGroup);
  
  if (!group) {
    throw new Error("Target group not found");
  }
  
  if (request.account) {
    const account = await Account.load(request.account.id);
    if (account) {
      // Now add the member and update the access
      group.addMember(account, "reader");
    }
  }
  
  return true;
}
```
</CodeGroup>
<br />
Example App coming soon!

