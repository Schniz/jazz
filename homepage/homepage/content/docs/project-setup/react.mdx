export const metadata = { title: "Installation" };

import { CodeGroup } from "@/components/forMdx";

# Installation and Setup

Add Jazz to your React application in minutes. This setup covers standard React apps, Next.js, and gives an overview of experimental SSR approaches.

1. Install dependencies
2. Write your schema
3. Wrap your app in `<JazzProvider />`



## Install dependencies

First, install the required packages:

<CodeGroup>
```bash
pnpm install jazz-react jazz-tools
```
</CodeGroup>

## Standard React Setup

Wrap your application with `<JazzProvider />` to connect to the Jazz network and define your data schema:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account } from "jazz-tools";

export class MyAppAccount extends Account {}
// @filename: app.tsx
import * as React from "react";
import { createRoot } from 'react-dom/client';

function App() {
    return <div>Hello, world!</div>;
}
// ---cut---
// app.tsx
import { JazzProvider } from "jazz-react";
import { MyAppAccount } from "./schema";

createRoot(document.getElementById("root")!).render(
  <JazzProvider
    sync={{ peer: "wss://cloud.jazz.tools/?key=you@example.com" }}
    AccountSchema={MyAppAccount}
  >
    <App />
  </JazzProvider>
);

// Register your Account schema to enhance TypeScript support
declare module "jazz-react" {
  interface Register {
    Account: MyAppAccount;
  }
}
```
</CodeGroup>

This setup handles:
- Connection to the Jazz sync server
- Schema registration for type-safe data handling
- Local storage configuration

For complete provider options, see [Provider Configuration](/docs/project-setup/providers/react).

## Next.js Integration

### Client-side Only (Easiest)

The simplest approach for Next.js is client-side only integration:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account } from "jazz-tools";

export class MyAppAccount extends Account {}
// @filename: app.tsx
import * as React from "react";
// ---cut---
// app.tsx
"use client" // Mark as client component

import { JazzProvider } from "jazz-react";
import { MyAppAccount } from "./schema";

export function JazzWrapper({ children }: { children: React.ReactNode }) {
  return (
    <JazzProvider
      sync={{ peer: "wss://cloud.jazz.tools/?key=you@example.com" }}
      AccountSchema={MyAppAccount}
    >
      {children}
    </JazzProvider>
  );
}
```
</CodeGroup>

Remember to mark any component that uses Jazz hooks with `"use client"`:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account, co } from "jazz-tools";

export class MyAppAccount extends Account {
  name = co.string;
}
// @filename: Profile.tsx
import * as React from "react";
import { MyAppAccount } from "./schema";

declare module "jazz-react" {
  interface Register {
    Account: MyAppAccount;
  }
}
// ---cut---
// Profile.tsx
"use client"; // [!code ++]

import { useAccount } from "jazz-react";

export function Profile() {
  const { me } = useAccount();
    
  return <div>Hello, {me?.name}</div>;
}
```
</CodeGroup>

### SSR Support (Experimental)

For server-side rendering, Jazz offers experimental approaches:

- Pure SSR
- Hybrid SSR + Client Hydration

#### Pure SSR

Use Jazz in server components by directly loading data with `CoValue.load()`.

{/*
<CodeGroup>
```tsx twoslash
// @errors: 18047
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}

export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: PublicData.tsx
import * as React from "react";
import { ID } from "jazz-tools";
const collectionID = "co_z123" as ID<MyCollection>;
// ---cut---
// Server Component (no "use client" directive)
import { MyCollection, MyItem } from "./schema";

export default async function PublicData() {
  // Load data directly in the server component
  const items = await MyCollection.load(collectionID);
        
  if (!items) {
    return <div>Loading...</div>;
  }
    
  return (
    <ul>
      {items.map(item => (
        item ? <li key={item.id}>{item.title}</li> : null
      ))}
    </ul>
  );
}
```
</CodeGroup>
*/}

This works well for public data accessible to the server account.

#### Hybrid SSR + Client Hydration

For more complex cases, you can pre-render on the server and hydrate on the client:

1. Create a shared rendering component.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";
// ---cut---
// ItemList.tsx - works in both server and client contexts
export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
```
</CodeGroup>
*/}

2. Create a client hydration component.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}
export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";

export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
// @filename: ItemListHydrator.tsx
// ItemListHydrator.tsx
import * as React from "react";
import { useCoState } from "jazz-react";
import { ID } from "jazz-tools";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
"use client"

import { MyCollection, MyItem } from "./schema";
import { ItemList } from "./ItemList";
export function ItemListHydrator({ initialItems }: { initialItems: MyItem[] }) {
  // Hydrate with real-time data once client loads
  const myCollection = useCoState(MyCollection, myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(myCollection?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Use server data until client data is available
  const displayItems = items || initialItems;
    
  return <ItemList items={displayItems} />;
}
```
</CodeGroup>
*/}

3. Create a server component that pre-loads data.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}

export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";

export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
// @filename: ItemListHydrator.tsx
// ItemListHydrator.tsx
import * as React from "react";
import { useCoState } from "jazz-react";
import { ID } from "jazz-tools";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
"use client"

import { MyCollection, MyItem } from "./schema";
import { ItemList } from "./ItemList";
export function ItemListHydrator({ initialItems }: { initialItems: MyItem[] }) {
  // Hydrate with real-time data once client loads
  const myCollection = useCoState(MyCollection, myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(myCollection?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Use server data until client data is available
  const displayItems = items || initialItems;
    
  return <ItemList items={displayItems} />;
}
// @filename: ServerItemPage.tsx
import * as React from 'react';
import { ID } from "jazz-tools";
import { MyCollection, MyItem } from "./schema";
import { ItemListHydrator } from "./ItemListHydrator";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
// ServerItemPage.tsx
export default async function ServerItemPage() {
  // Pre-load data on the server
  const initialItems = await MyCollection.load(myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(initialItems?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Pass to client hydrator
  return <ItemListHydrator initialItems={items} />;
}
```
</CodeGroup>
*/}

This approach gives you the best of both worlds: fast initial loading with server rendering, plus real-time updates on the client.

## Next Steps

- [Schemas](/docs/schemas/covalues) - Define your data model
- [Provider Configuration](/docs/project-setup/providers) - Complete provider options
- [Authentication](/docs/authentication/overview) - Set up user authentication
- [Sync and Storage](/docs/sync-and-storage) - Configure data persistence

