export const metadata = { title: "Defining schemas: CoValues" };

import { CodeGroup, ComingSoon } from "@/components/forMdx";

# Defining schemas: CoValues

**CoValues ("Collaborative Values") are the core abstraction of Jazz.** They're your bread-and-butter datastructures that you use to represent everything in your app.

As their name suggests, CoValues are inherently collaborative, meaning **multiple users and devices can edit them at the same time.**

**Think of CoValues as "super-fast Git for lots of tiny data."**

- CoValues keep their full edit histories, from which they derive their "current state".
- The fact that this happens in an eventually-consistent way makes them [CRDTs](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type).
- Having the full history also means that you often don't need explicit timestamps and author info - you get this for free as part of a CoValue's [edit metadata](/docs/using-covalues/history).

CoValues model JSON with CoMaps and CoLists, but also offer CoFeeds for simple per-user value feeds, and let you represent binary data with FileStreams.

## Start your app with a schema

Fundamentally, CoValues are as dynamic and flexible as JSON, but in Jazz you use them by defining fixed schemas to describe the shape of data in your app.

This helps correctness and development speed, but is particularly important...
- when you evolve your app and need migrations
- when different clients and server workers collaborate on CoValues and need to make compatible changes

Thinking about the shape of your data is also a great first step to model your app.

Even before you know the details of how your app will work, you'll probably know which kinds of objects it will deal with, and how they relate to each other.

TODO: UPDATE THIS Jazz makes it quick to declare schemas, since they are simple TypeScript classes:

<CodeGroup>
```ts twoslash
import { co, z, CoMap, CoList } from "jazz-tools";
// ---cut---
// schema.ts
const ListOfTasks = co.list(z.string());

export const TodoProject = co.map({
  title: z.string(),
  tasks: ListOfTasks,
});
```
</CodeGroup>

TODO: UPDATE THIS Here you can see how we extend a CoValue type and use `co` for declaring (collaboratively) editable fields. This means that schema info is available for type inference *and* at runtime.

TODO: UPDATE THIS Classes might look old-fashioned, but Jazz makes use of them being both types and values in TypeScript, letting you refer to either with a single definition and import.

<CodeGroup>
```ts twoslash
// @filename: schema.ts
import { co, z, CoMap, CoList } from "jazz-tools";

export const ListOfTasks = co.list(z.string());

export const TodoProject = co.map({
  title: z.string(),
  tasks: ListOfTasks,
});

// @filename: app.ts
import { Group } from "jazz-tools";
// ---cut---
// app.ts
import { TodoProject, ListOfTasks } from "./schema";

const project = TodoProject.create(
  {
    title: "New Project",
    tasks: ListOfTasks.create([], Group.create()),
  },
  Group.create()
);
```
</CodeGroup>

## Types of CoValues

### `CoMap` (declaration)

CoMaps are the most commonly used type of CoValue. They are the equivalent of JSON objects (Collaborative editing follows a last-write-wins strategy per-key).

You can either declare struct-like CoMaps:

<CodeGroup>
```ts twoslash
// schema.ts
import { co, z } from "jazz-tools";
// ---cut---
const Task = co.map({
  title: z.string(),
  completed: z.boolean(),
});
```
</CodeGroup>

Or record-like CoMaps (key-value pairs, where keys are always `string`):

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";
const Fruit = co.map({
  name: z.string(),
  color: z.string(),
});
// ---cut---
const ColorToHex = co.record(z.string(), z.string());

const ColorToFruit = co.record(z.string(), Fruit);
```
</CodeGroup>


See the corresponding sections for [creating](/docs/using-covalues/comaps#creating-comaps),
[subscribing/loading](/docs/using-covalues/subscription-and-loading),
[reading from](/docs/using-covalues/comaps#reading-from-comaps) and
[updating](/docs/using-covalues/comaps#updating-comaps) CoMaps.

### `CoList` (declaration)

CoLists are ordered lists and are the equivalent of JSON arrays. (They support concurrent insertions and deletions, maintaining a consistent order.)

You define them by specifying the type of the items they contain:

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";
const Task = co.map({
  title: z.string(),
  completed: z.boolean(),
});
// ---cut---
const ListOfColors = co.list(z.string());
const ListOfTasks = co.list(Task);
```
</CodeGroup>

See the corresponding sections for [creating](/docs/using-covalues/colists#creating-colists),
[subscribing/loading](/docs/using-covalues/subscription-and-loading),
[reading from](/docs/using-covalues/colists#reading-from-colists) and
[updating](/docs/using-covalues/colists#updating-colists) CoLists.

### `CoFeed` (declaration)

CoFeeds are a special CoValue type that represent a feed of values for a set of users/sessions (Each session of a user gets its own append-only feed).

They allow easy access of the latest or all items belonging to a user or their sessions. This makes them particularly useful for user presence, reactions, notifications, etc.

You define them by specifying the type of feed item:

<CodeGroup>
```ts twoslash
import { co, z, CoFeed } from "jazz-tools";
const Task = co.map({
  title: z.string(),
  completed: z.boolean(),
});
// ---cut---
class FeedOfTasks extends CoFeed.Of(coField.ref(Task)) {}
```
</CodeGroup>

See the corresponding sections for [creating](/docs/using-covalues/cofeeds#creating-cofeeds),
[subscribing/loading](/docs/using-covalues/subscription-and-loading),
[reading from](/docs/using-covalues/cofeeds#reading-from-cofeeds) and
[writing to](/docs/using-covalues/cofeeds#writing-to-cofeeds) CoFeeds.

### `FileStream` (declaration)

FileStreams are a special type of CoValue that represent binary data. (They are created by a single user and offer no internal collaboration.)

They allow you to upload and reference files, images, etc.

You typically don't need to declare or extend them yourself, you simply refer to the built-in `FileStream` from another CoValue:

<CodeGroup>
```ts twoslash
import { co, z } from "jazz-tools";
// ---cut---
const Document = co.map({
  title: z.string(),
  file: co.file(),
});
```
</CodeGroup>

See the corresponding sections for [creating](/docs/using-covalues/filestreams#creating-filestreams),
[subscribing/loading](/docs/using-covalues/subscription-and-loading),
[reading from](/docs/using-covalues/filestreams#reading-from-filestreams) and
[writing to](/docs/using-covalues/filestreams#writing-to-filestreams) FileStreams.

### `SchemaUnion` (declaration)

SchemaUnion is a helper type that allows you to load and refer to multiple subclasses of a CoMap schema, distinguished by a discriminating field.

You declare them with a base class type and discriminating lambda, in which you have access to the `RawCoMap`, on which you can call `get` with the field name to get the discriminating value.

<CodeGroup>
```ts twoslash
import { co } from "jazz-tools";
// ---cut---
import { SchemaUnion, CoMap } from "jazz-tools";

class BaseWidget extends CoMap {
  type = coField.string;
}

class ButtonWidget extends BaseWidget {
  type = coField.literal("button");
  label = coField.string;
}

class SliderWidget extends BaseWidget {
  type = coField.literal("slider");
  min = coField.number;
  max = coField.number;
}

const WidgetUnion = SchemaUnion.Of<BaseWidget>((raw) => {
  switch (raw.get("type")) {
    case "button": return ButtonWidget;
    case "slider": return SliderWidget;
    default: throw new Error("Unknown widget type");
  }
});
```
</CodeGroup>

See the corresponding sections for [creating](/docs/using-covalues/schemaunions#creating-schemaunions),
[subscribing/loading](/docs/using-covalues/subscription-and-loading) and
[narrowing](/docs/using-covalues/schemaunions#narrowing) SchemaUnions.

## CoValue field/item types

Now that we've seen the different types of CoValues, let's see more precisely how we declare the fields or items they contain.

### Primitive fields

You can declare primitive field types using the `co` declarer:

<CodeGroup>
```ts twoslash
import { coField, CoMap, CoList } from "jazz-tools";

export class Person extends CoMap {
  title = coField.string;
}

export class ListOfColors extends CoList.Of(coField.string) {}
```
</CodeGroup>

Here's a quick overview of the primitive types you can use:

<CodeGroup>
```ts twoslash
import { coField } from "jazz-tools";
// ---cut---
coField.string;  // For simple strings
coField.number;  // For numbers
coField.boolean; // For booleans
coField.null;    // For null
coField.Date;    // For dates
co.literal("waiting", "ready"); // For enums
```
</CodeGroup>

Finally, for more complex JSON data, that you *don't want to be collaborative internally* (but only ever update as a whole), you can use `coField.json<T>()`:

<CodeGroup>
```ts twoslash
import { coField } from "jazz-tools";
// ---cut---
coField.json<{ name: string }>(); // For JSON objects
```
</CodeGroup>

For more detail, see the API Reference for the [`co` field declarer](/api-reference/jazz-tools#co).

### Refs to other CoValues

To represent complex structured data with Jazz, you form trees or graphs of CoValues that reference each other.

Internally, this is represented by storing the IDs of the referenced CoValues in the corresponding fields, but Jazz abstracts this away, making it look like nested CoValues you can get or assign/insert.

The important caveat here is that **a referenced CoValue might or might not be loaded yet,** but we'll see what exactly that means in [Subscribing and Deep Loading](/docs/using-covalues/subscription-and-loading).

In Schemas, you declare Refs using the `coField.ref<T>()` declarer:

<CodeGroup>
```ts twoslash
import { coField, CoMap, CoList } from "jazz-tools";
class Person extends CoMap {
  name = coField.string;
}
// ---cut---
// schema.ts
class ListOfPeople extends CoList.Of(coField.ref(Person)) {}

class Company extends CoMap {
  members = coField.ref(ListOfPeople);
}
```
</CodeGroup>

#### Optional Refs

⚠️ If you want to make a referenced CoValue field optional, you *have to* use `coField.optional.ref<T>()`: ⚠️

<CodeGroup>
```ts twoslash
import { coField, CoMap } from "jazz-tools";
class Pet extends CoMap {
  name = coField.string;
}
// ---cut---
class Person extends CoMap {
  pet = coField.optional.ref(Pet);
}
```
</CodeGroup>

### Computed fields & methods

You can use the `withHelpers` method on CoValue schemas to add helper functions to the schema itself.

These typically take a parameter of a loaded CoValue of the schema.

<CodeGroup>
```ts twoslash
import { co, z, CoMap, Loaded } from "jazz-tools";
function differenceInYears(date1: Date, date2: Date) {
  const diffTime = Math.abs(date1.getTime() - date2.getTime());
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 365.25));
}
// ---cut---
const Person = co.map({
  firstName: z.string(),
  lastName: z.string(),
  dateOfBirth: z.Date(),
}).withHelpers({
  name(person: Loaded<typeof Person>) {
    return `${person.firstName} ${person.lastName}`;
  }

  ageAsOf(person: Loaded<typeof Person>, date: Date) {
    return differenceInYears(date, person.dateOfBirth);
  }
});

const person = Person.create({
  firstName: "John",
  lastName: "Doe",
  dateOfBirth: new Date("1990-01-01"),
});

const age = Person.ageAsOf(person, new Date());
```
</CodeGroup>
